// Generated by CoffeeScript 1.3.3
var Packer, blockDeduplication, blocks, boxAreas, combinations, dataURLtoCanvas, denseIndex, differenceBoxes, f, fastAdjacentMerge, frames, imageSearch, iteratedMerge, lastFrame, parseDenseIndex, postProcessing, processFrame, rowString;

frames = chrome.extension.getBackgroundPage().frames;

dataURLtoCanvas = function(dataURL, callback) {
  var canvas, ctx, img;
  img = new Image();
  canvas = document.createElement('canvas');
  ctx = canvas.getContext('2d');
  img.src = dataURL;
  return img.onload = function() {
    canvas.width = img.width;
    canvas.height = img.height;
    ctx.drawImage(img, 0, 0);
    return callback(canvas, img, ctx, ctx.getImageData(0, 0, img.width, img.height));
  };
};

f = 0;

blocks = [];

lastFrame = null;

rowString = function(pixels, y) {
  var pix, row, x, _i, _ref;
  row = "";
  for (x = _i = 0, _ref = pixels.width; 0 <= _ref ? _i < _ref : _i > _ref; x = 0 <= _ref ? ++_i : --_i) {
    pix = (y * pixels.width + x) * 4;
    row += String.fromCharCode(pixels.data[pix]);
  }
  return row;
};

imageSearch = function(needle, haystack) {
  var bestReduce, bestRow, confirmTheory, firstRow, hpix, index, n, npix, nthCandidates, nthRow, pixc, reduce, row, rowCandidates, y, _i, _j, _k, _l, _len, _len1, _ref, _ref1;
  if (needle.width > haystack.width) {
    return null;
  }
  if (needle.height > haystack.height) {
    return null;
  }
  hpix = function(x, y) {
    var pix;
    pix = (y * haystack.width + x) * 4;
    return [haystack.data[pix], haystack.data[pix + 1], haystack.data[pix + 2]];
  };
  npix = function(x, y) {
    var pix;
    pix = (y * needle.width + x) * 4;
    return [needle.data[pix], needle.data[pix + 1], needle.data[pix + 2]];
  };
  pixc = function(_arg, _arg1) {
    var B, G, R, b, g, r;
    r = _arg[0], g = _arg[1], b = _arg[2];
    R = _arg1[0], G = _arg1[1], B = _arg1[2];
    return r === R && g === G && b === B;
  };
  confirmTheory = function(hx, hy) {
    var x, y, _i, _j, _ref, _ref1;
    for (y = _i = 1, _ref = needle.height; 1 <= _ref ? _i < _ref : _i > _ref; y = 1 <= _ref ? ++_i : --_i) {
      for (x = _j = 0, _ref1 = needle.width; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
        if (!pixc(hpix(hx + x, hy + y), npix(x, y))) {
          return;
        }
      }
    }
    return true;
  };
  firstRow = rowString(needle, 0);
  rowCandidates = [];
  for (y = _i = 0, _ref = haystack.height - needle.height; 0 <= _ref ? _i < _ref : _i > _ref; y = 0 <= _ref ? ++_i : --_i) {
    row = rowString(haystack, y);
    if (row.indexOf(firstRow !== -1)) {
      rowCandidates.push(y);
    }
  }
  if (rowCandidates.length === 0) {
    return null;
  }
  bestReduce = 0;
  bestRow = 0;
  for (n = _j = 1, _ref1 = haystack.height; 1 <= _ref1 ? _j < _ref1 : _j > _ref1; n = 1 <= _ref1 ? ++_j : --_j) {
    nthRow = rowString(needle, n);
    nthCandidates = [];
    for (_k = 0, _len = rowCandidates.length; _k < _len; _k++) {
      y = rowCandidates[_k];
      row = rowString(haystack, y + n);
      if (row.indexOf(nthRow) !== -1) {
        nthCandidates.push(y);
      }
    }
    if (nthCandidates.length === 0) {
      return null;
    }
    reduce = rowCandidates.length - nthCandidates.length;
    if (reduce > bestReduce) {
      bestReduce = reduce;
      bestRow = n;
    }
    rowCandidates = nthCandidates;
    if (nthCandidates.length === 1) {
      break;
    }
  }
  if (rowCandidates.length > 100) {
    console.log("reduce failure", rowCandidates.length);
    return;
  }
  for (_l = 0, _len1 = rowCandidates.length; _l < _len1; _l++) {
    y = rowCandidates[_l];
    index = -1;
    nthRow = rowString(needle, bestRow);
    row = rowString(haystack, y + bestRow);
    while ((index = row.indexOf(nthRow, index + 1)) !== -1) {
      if (confirmTheory(index, y)) {
        console.log("an actual match", index, y, needle.width, needle.height);
        return [index, y];
      }
    }
  }
};

blockDeduplication = function(blocks) {
  var block, candidate, candidates, coords, subset, test, xoff, xsub, yoff, ysub, _i, _len, _results;
  _results = [];
  for (_i = 0, _len = blocks.length; _i < _len; _i++) {
    block = blocks[_i];
    candidates = (function() {
      var _j, _len1, _results1;
      _results1 = [];
      for (_j = 0, _len1 = blocks.length; _j < _len1; _j++) {
        test = blocks[_j];
        if (!test.isSubset && test.w >= block.w && test.h >= block.h && test !== block) {
          _results1.push(test);
        }
      }
      return _results1;
    })();
    console.log("Iterating through block parent candidates", candidates.length);
    _results.push((function() {
      var _j, _k, _len1, _len2, _ref, _ref1, _results1;
      _results1 = [];
      for (_j = 0, _len1 = candidates.length; _j < _len1; _j++) {
        candidate = candidates[_j];
        coords = imageSearch(block.pixels, candidate.pixels);
        if (coords) {
          block.isSubset = true;
          block.coords = coords;
          if (!('subsets' in candidate)) {
            candidate.subsets = [];
          }
          candidate.subsets.push(block);
          if ('subsets' in block) {
            xoff = coords[0], yoff = coords[1];
            _ref = block.subsets;
            for (_k = 0, _len2 = _ref.length; _k < _len2; _k++) {
              subset = _ref[_k];
              _ref1 = subset.coords, xsub = _ref1[0], ysub = _ref1[1];
              subset.coords = [xoff + xsub, yoff + ysub];
              candidate.subsets.push(subset);
            }
          }
          break;
        } else {
          _results1.push(void 0);
        }
      }
      return _results1;
    })());
  }
  return _results;
};

postProcessing = function() {
  var alg, bestSort, block, boxes, canvas, coords, ctx, fit, frame, h, image, index, isSubset, maxheight, maxwidth, minHeight, msort, offsetX, offsetY, pack, preview, reduced, sorts, subsets, w, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3, _ref4;
  msort = function(a, b, criteria) {
    var criterion, diff, _i, _len;
    for (_i = 0, _len = criteria.length; _i < _len; _i++) {
      criterion = criteria[_i];
      diff = sorts[criterion](a, b);
      if (diff !== 0) {
        return diff;
      }
    }
    return 0;
  };
  sorts = {
    random: function(a, b) {
      return Math.random() - 0.5;
    },
    w: function(a, b) {
      return b.w - a.w;
    },
    h: function(a, b) {
      return b.h - a.h;
    },
    a: function(a, b) {
      return b.area - a.area;
    },
    max: function(a, b) {
      return Math.max(b.w, b.h) - Math.max(a.w, a.h);
    },
    min: function(a, b) {
      return Math.min(b.w, b.h) - Math.min(a.w, a.h);
    },
    height: function(a, b) {
      return msort(a, b, ['h', 'w']);
    },
    width: function(a, b) {
      return msort(a, b, ['w', 'h']);
    },
    area: function(a, b) {
      return msort(a, b, ['a', 'h', 'w']);
    },
    maxside: function(a, b) {
      return msort(a, b, ['max', 'min', 'h', 'w']);
    }
  };
  blocks = blocks.sort(sorts.area);
  blockDeduplication(blocks);
  console.log("Fitting boxes together");
  reduced = (function() {
    var _i, _len, _results;
    _results = [];
    for (_i = 0, _len = blocks.length; _i < _len; _i++) {
      block = blocks[_i];
      if (!block.isSubset) {
        _results.push(block);
      }
    }
    return _results;
  })();
  minHeight = Infinity;
  bestSort = '';
  maxwidth = blocks[0].w;
  maxheight = blocks[0].h;
  _ref = ["width", "height", "area", "maxside"];
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    alg = _ref[_i];
    boxes = ((function() {
      var _j, _len1, _ref1, _results;
      _results = [];
      for (_j = 0, _len1 = reduced.length; _j < _len1; _j++) {
        _ref1 = reduced[_j], w = _ref1.w, h = _ref1.h;
        _results.push({
          w: w,
          h: h
        });
      }
      return _results;
    })()).sort(sorts[alg]);
    if (boxes[0].w !== maxwidth || boxes[0].h !== maxheight) {
      continue;
    }
    console.log(boxes);
    pack = new Packer(maxwidth, maxheight);
    pack.fit(boxes);
    console.log(alg, pack.root.h);
    if (pack.root.h < minHeight) {
      minHeight = pack.root.h;
      bestSort = alg;
    }
  }
  blocks = blocks.sort(sorts[bestSort]);
  pack = new Packer(maxwidth, maxheight);
  pack.fit(blocks);
  canvas = document.createElement('canvas');
  ctx = canvas.getContext('2d');
  canvas.width = pack.root.w;
  canvas.height = pack.root.h;
  ctx.fillStyle = '#007fff';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  index = [];
  for (_j = 0, _len1 = blocks.length; _j < _len1; _j++) {
    _ref1 = blocks[_j], frame = _ref1.frame, image = _ref1.image, offsetX = _ref1.offsetX, offsetY = _ref1.offsetY, w = _ref1.w, h = _ref1.h, fit = _ref1.fit, subsets = _ref1.subsets, isSubset = _ref1.isSubset;
    w = Math.min(w, image.width - offsetX);
    h = Math.min(h, image.height - offsetY);
    ctx.drawImage(image, offsetX, offsetY, w, h, fit.x, fit.y, w, h);
    if (!isSubset) {
      index.push({
        f: frame,
        sX: fit.x,
        sY: fit.y,
        bX: offsetX,
        bY: offsetY,
        w: w,
        h: h
      });
    }
    if (subsets) {
      for (_k = 0, _len2 = subsets.length; _k < _len2; _k++) {
        _ref2 = subsets[_k], frame = _ref2.frame, w = _ref2.w, h = _ref2.h, coords = _ref2.coords, offsetX = _ref2.offsetX, offsetY = _ref2.offsetY;
        index.push({
          f: frame,
          sX: fit.x + coords[0],
          sY: fit.y + coords[1],
          bX: offsetX,
          bY: offsetY,
          w: w,
          h: h
        });
      }
    }
  }
  preview = document.getElementById('preview');
  _ref3 = [canvas.width, canvas.height], preview.width = _ref3[0], preview.height = _ref3[1];
  preview = preview.getContext('2d');
  preview.drawImage(canvas, 0, 0);
  preview.strokeStyle = 'green';
  for (_l = 0, _len3 = blocks.length; _l < _len3; _l++) {
    _ref4 = blocks[_l], frame = _ref4.frame, image = _ref4.image, offsetX = _ref4.offsetX, offsetY = _ref4.offsetY, w = _ref4.w, h = _ref4.h, fit = _ref4.fit, subsets = _ref4.subsets;
    preview.strokeRect(fit.x, fit.y, w, h);
    preview.fillText('(' + offsetX + ',' + offsetY + ')', fit.x, fit.y);
  }
  index = index.sort(function(a, b) {
    return a.f - b.f;
  });
  return finalize(canvas, index, denseIndex(index, [canvas.width, canvas.height]));
};

denseIndex = function(index, _arg) {
  var a, bX, bY, digits, h, maxnum, n, newindex, number, sX, sY, w, _i, _len, _ref;
  w = _arg[0], h = _arg[1];
  maxnum = Math.max(w, h, index[index.length - 1].f);
  digits = Math.ceil(Math.log(maxnum) / Math.log(36));
  newindex = [];
  for (_i = 0, _len = index.length; _i < _len; _i++) {
    _ref = index[_i], f = _ref.f, sX = _ref.sX, sY = _ref.sY, bX = _ref.bX, bY = _ref.bY, w = _ref.w, h = _ref.h;
    newindex = newindex.concat([f, sX, sY, bX, bY, w, h]);
  }
  a = (function() {
    var _j, _len1, _results;
    _results = [];
    for (_j = 0, _len1 = newindex.length; _j < _len1; _j++) {
      number = newindex[_j];
      n = number.toString(36);
      while (n.length < digits) {
        n = '0' + n;
      }
      _results.push(n);
    }
    return _results;
  })();
  return a.join('');
};

parseDenseIndex = function(str) {
  var bX, bY, digits, h, i, item, j, sX, sY, w, _i, _ref, _ref1, _ref2, _results;
  digits = /^0+/.match(str)[0].length / 5;
  _results = [];
  for (i = _i = 0, _ref = str.length, _ref1 = 7 * digits; 0 <= _ref ? _i < _ref : _i > _ref; i = _i += _ref1) {
    item = str.slice(i, digits);
    _results.push((_ref2 = (function() {
      var _j, _ref2, _results1;
      _results1 = [];
      for (j = _j = 0, _ref2 = item.length; 0 <= _ref2 ? _j < _ref2 : _j > _ref2; j = _j += digits) {
        _results1.push(parseInt(item.slice(j, digits), 36));
      }
      return _results1;
    })(), f = _ref2[0], sX = _ref2[1], sY = _ref2[2], bX = _ref2[3], bY = _ref2[4], w = _ref2[5], h = _ref2[6], _ref2));
  }
  return _results;
};

processFrame = function() {
  var frame;
  frame = f++;
  if (frame >= frames.length) {
    console.log("reached end of video");
    postProcessing();
    return;
  }
  if (frames[frame] === "") {
    return processFrame();
  }
  return dataURLtoCanvas(frames[frame], function(canvas, image, ctx, pixels) {
    var boxes, c, data, height, preview, ts, width, x1, x2, y1, y2, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
    data = pixels.data, width = pixels.width, height = pixels.height;
    ts = +(new Date);
    c = document.getElementById('preview');
    c.width = width;
    c.height = height;
    preview = c.getContext('2d');
    preview.drawImage(canvas, 0, 0);
    if (frame === 0) {
      console.log("first frame, woot");
      blocks.push({
        frame: frame,
        image: image,
        ctx: ctx,
        w: width,
        h: height,
        offsetX: 0,
        offsetY: 0,
        pixels: pixels
      });
    } else {
      console.time("calculate initial boxes from contiguous lines");
      boxes = differenceBoxes(width, height, lastFrame, data);
      console.timeEnd("calculate initial boxes from contiguous lines");
      console.time("Iterated box merging");
      boxes = iteratedMerge(boxes);
      console.timeEnd("Iterated box merging");
      boxes = (function() {
        var _i, _len, _ref, _results;
        _results = [];
        for (_i = 0, _len = boxes.length; _i < _len; _i++) {
          _ref = boxes[_i], x1 = _ref[0], y1 = _ref[1], x2 = _ref[2], y2 = _ref[3];
          if (x2 - x1 > 0 && y2 - y1 > 0) {
            _results.push([x1, y1, x2, y2]);
          }
        }
        return _results;
      })();
      preview.strokeStyle = "green";
      for (_i = 0, _len = boxes.length; _i < _len; _i++) {
        _ref = boxes[_i], x1 = _ref[0], y1 = _ref[1], x2 = _ref[2], y2 = _ref[3];
        preview.strokeRect(x1 + .5, y1 + .5, x2 - x1 + .5, y2 - y1 + .5);
      }
      console.log("Exporting the blocks", boxes.length, boxes);
      for (_j = 0, _len1 = boxes.length; _j < _len1; _j++) {
        _ref1 = boxes[_j], x1 = _ref1[0], y1 = _ref1[1], x2 = _ref1[2], y2 = _ref1[3];
        preview.strokeRect(x1, y1, x2 - x1, y2 - y1);
      }
      for (_k = 0, _len2 = boxes.length; _k < _len2; _k++) {
        _ref2 = boxes[_k], x1 = _ref2[0], y1 = _ref2[1], x2 = _ref2[2], y2 = _ref2[3];
        blocks.push({
          frame: frame,
          image: image,
          ctx: ctx,
          w: x2 - x1 + 1,
          h: y2 - y1 + 1,
          offsetX: x1,
          offsetY: y1,
          pixels: ctx.getImageData(x1, y1, x2 - x1, y2 - y1)
        });
      }
    }
    lastFrame = data;
    if (boxes && boxes.length > 1) {
      return setTimeout(processFrame, 5000);
    } else {
      return setTimeout(processFrame, 50);
    }
  });
};

differenceBoxes = function(width, height, lastFrame, currentFrame) {
  var boxes, lastX, pix, startX, x, y, _i, _j;
  boxes = [];
  for (y = _i = 0; 0 <= height ? _i <= height : _i >= height; y = 0 <= height ? ++_i : --_i) {
    lastX = null;
    startX = null;
    for (x = _j = 0; 0 <= width ? _j <= width : _j >= width; x = 0 <= width ? ++_j : --_j) {
      pix = (y * width + x) * 4;
      if (lastFrame[pix] !== currentFrame[pix] || lastFrame[pix + 1] !== currentFrame[pix + 1] || lastFrame[pix + 2] !== currentFrame[pix + 2]) {
        lastX = x;
        if (startX === null) {
          startX = x;
        }
      }
      if (x - lastX > 20 && startX !== null) {
        boxes.push([startX, y, lastX, y + 1]);
        startX = null;
      }
    }
    if (startX !== null) {
      boxes.push([startX, y, lastX, y + 1]);
    }
  }
  return boxes;
};

iteratedMerge = function(boxes) {
  var axis, i, newboxes, _i, _j, _len, _ref;
  newboxes = [];
  for (i = _i = 0; _i < 2; i = ++_i) {
    _ref = [1, 0, 3, 2];
    for (_j = 0, _len = _ref.length; _j < _len; _j++) {
      axis = _ref[_j];
      while ((newboxes = fastAdjacentMerge(boxes, axis)).length < boxes.length) {
        boxes = newboxes;
      }
    }
  }
  return boxes;
};

combinations = function(list) {
  var a, b, newlist, _i, _j, _ref;
  newlist = [];
  for (a = _i = 0, _ref = list.length; 0 <= _ref ? _i < _ref : _i > _ref; a = 0 <= _ref ? ++_i : --_i) {
    for (b = _j = 0; 0 <= a ? _j < a : _j > a; b = 0 <= a ? ++_j : --_j) {
      newlist.push([list[a], list[b]]);
    }
  }
  return newlist;
};

boxAreas = function(a, b) {
  var aarea, ax1, ax2, ay1, ay2, barea, bx1, bx2, by1, by2, dHeight, dWidth, maxHeight, maxWidth, sarea, sx1, sx2, sy1, sy2;
  bx1 = b[0], by1 = b[1], bx2 = b[2], by2 = b[3];
  ax1 = a[0], ay1 = a[1], ax2 = a[2], ay2 = a[3];
  aarea = (ax2 - ax1) * (ay2 - ay1);
  barea = (bx2 - bx1) * (by2 - by1);
  maxWidth = Math.max(bx2 - bx1, ax2 - ax1);
  maxHeight = Math.max(ay2 - ay1, by2 - by1);
  sx1 = Math.min(ax1, bx1);
  sx2 = Math.max(ax2, bx2);
  sy1 = Math.min(ay1, by1);
  sy2 = Math.max(ay2, by2);
  sarea = (sy2 - sy1) * (sx2 - sx1);
  dWidth = (sx2 - sx1) - maxWidth;
  dHeight = (sy2 - sy1) - maxHeight;
  return [sarea, barea + aarea, [sx1, sy1, sx2, sy2], [dWidth, dHeight]];
};

fastAdjacentMerge = function(boxes, axis) {
  var dH, dW, i, newbox, newboxes, sarea, skipNext, tarea, _i, _ref, _ref1, _ref2;
  boxes = boxes.sort(function(a, b) {
    return a[axis] - b[axis];
  });
  newboxes = [];
  skipNext = false;
  if (boxes.length > 0) {
    for (i = _i = 0, _ref = boxes.length - 1; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      _ref1 = boxAreas(boxes[i], boxes[i + 1]), sarea = _ref1[0], tarea = _ref1[1], newbox = _ref1[2], (_ref2 = _ref1[3], dW = _ref2[0], dH = _ref2[1]);
      if ((sarea - tarea < 256 || (sarea * 0.5 <= tarea && dW < 20 && dH < 20)) && !skipNext) {
        newboxes.push(newbox);
        skipNext = true;
      } else {
        if (!skipNext) {
          newboxes.push(boxes[i]);
        }
        skipNext = false;
      }
    }
    if (!skipNext) {
      newboxes.push(boxes[boxes.length - 1]);
    }
  }
  return newboxes;
};

Packer = (function() {

  function Packer(w, h) {
    this.root = {
      x: 0,
      y: 0,
      w: w,
      h: h
    };
  }

  Packer.prototype.fit = function(blocks) {
    var block, node, _i, _len;
    for (_i = 0, _len = blocks.length; _i < _len; _i++) {
      block = blocks[_i];
      if (node = this.findNode(this.root, block.w, block.h)) {
        block.fit = this.splitNode(node, block.w, block.h);
      } else {
        block.fit = this.growNode(block.w, block.h);
      }
    }
    return blocks;
  };

  Packer.prototype.findNode = function(root, w, h) {
    if (root.used) {
      return this.findNode(root.right, w, h) || this.findNode(root.down, w, h);
    } else if ((w <= root.w) && (h <= root.h)) {
      return root;
    } else {
      return null;
    }
  };

  Packer.prototype.growNode = function(w, h) {
    var node;
    this.root = {
      used: true,
      x: 0,
      y: 0,
      w: this.root.w,
      h: this.root.h + h,
      down: {
        x: 0,
        y: this.root.h,
        w: this.root.w,
        h: h
      },
      right: this.root
    };
    if (node = this.findNode(this.root, w, h)) {
      return this.splitNode(node, w, h);
    } else {
      return null;
    }
  };

  Packer.prototype.splitNode = function(node, w, h) {
    node.used = true;
    node.down = {
      x: node.x,
      y: node.y + h,
      w: node.w,
      h: node.h - h
    };
    node.right = {
      x: node.x + w,
      y: node.y,
      w: node.w - w,
      h: h
    };
    return node;
  };

  return Packer;

})();
