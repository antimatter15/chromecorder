// Generated by CoffeeScript 1.3.3
var boxAreas, differenceBoxes, fastAdjacentMerge, iteratedMerge, lastFrame;

lastFrame = null;

addEventListener('message', function(e) {
  var boxes, buf, data, frame, height, width, x1, x2, y1, y2, _ref;
  _ref = e.data, buf = _ref.buf, width = _ref.width, height = _ref.height, frame = _ref.frame;
  data = new Uint8ClampedArray(buf);
  if (frame === 0) {
    postMessage([[0, 0, width, height]]);
  } else {
    boxes = differenceBoxes(width, height, lastFrame, data);
    boxes = iteratedMerge(boxes);
    boxes = (function() {
      var _i, _len, _ref1, _results;
      _results = [];
      for (_i = 0, _len = boxes.length; _i < _len; _i++) {
        _ref1 = boxes[_i], x1 = _ref1[0], y1 = _ref1[1], x2 = _ref1[2], y2 = _ref1[3];
        if (x2 - x1 > 0 && y2 - y1 > 0) {
          _results.push([x1, y1, x2, y2]);
        }
      }
      return _results;
    })();
    postMessage(boxes);
  }
  return lastFrame = data;
});

differenceBoxes = function(width, height, lastFrame, currentFrame) {
  var boxes, lastX, pix, startX, x, y, _i, _j;
  boxes = [];
  for (y = _i = 0; 0 <= height ? _i <= height : _i >= height; y = 0 <= height ? ++_i : --_i) {
    lastX = null;
    startX = null;
    for (x = _j = 0; 0 <= width ? _j <= width : _j >= width; x = 0 <= width ? ++_j : --_j) {
      pix = (y * width + x) * 4;
      if (lastFrame[pix] !== currentFrame[pix] || lastFrame[pix + 1] !== currentFrame[pix + 1] || lastFrame[pix + 2] !== currentFrame[pix + 2]) {
        lastX = x;
        if (startX === null) {
          startX = x;
        }
      }
      if (x - lastX > 20 && startX !== null) {
        boxes.push([startX, y, lastX, y + 1]);
        startX = null;
      }
    }
    if (startX !== null) {
      boxes.push([startX, y, lastX, y + 1]);
    }
  }
  return boxes;
};

boxAreas = function(a, b) {
  var aarea, ax1, ax2, ay1, ay2, barea, bx1, bx2, by1, by2, dHeight, dWidth, maxHeight, maxWidth, sarea, sx1, sx2, sy1, sy2;
  bx1 = b[0], by1 = b[1], bx2 = b[2], by2 = b[3];
  ax1 = a[0], ay1 = a[1], ax2 = a[2], ay2 = a[3];
  aarea = (ax2 - ax1) * (ay2 - ay1);
  barea = (bx2 - bx1) * (by2 - by1);
  maxWidth = Math.max(bx2 - bx1, ax2 - ax1);
  maxHeight = Math.max(ay2 - ay1, by2 - by1);
  sx1 = Math.min(ax1, bx1);
  sx2 = Math.max(ax2, bx2);
  sy1 = Math.min(ay1, by1);
  sy2 = Math.max(ay2, by2);
  sarea = (sy2 - sy1) * (sx2 - sx1);
  dWidth = (sx2 - sx1) - maxWidth;
  dHeight = (sy2 - sy1) - maxHeight;
  return [sarea, barea + aarea, [sx1, sy1, sx2, sy2], [dWidth, dHeight]];
};

iteratedMerge = function(boxes) {
  var axis, i, newboxes, _i, _j, _len, _ref;
  newboxes = [];
  for (i = _i = 0; _i < 2; i = ++_i) {
    _ref = [1, 0, 3, 2];
    for (_j = 0, _len = _ref.length; _j < _len; _j++) {
      axis = _ref[_j];
      while ((newboxes = fastAdjacentMerge(boxes, axis)).length < boxes.length) {
        boxes = newboxes;
      }
    }
  }
  return boxes;
};

fastAdjacentMerge = function(boxes, axis) {
  var dH, dW, i, newbox, newboxes, sarea, skipNext, tarea, _i, _ref, _ref1, _ref2;
  boxes = boxes.sort(function(a, b) {
    return a[axis] - b[axis];
  });
  newboxes = [];
  skipNext = false;
  if (boxes.length > 0) {
    for (i = _i = 0, _ref = boxes.length - 1; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      _ref1 = boxAreas(boxes[i], boxes[i + 1]), sarea = _ref1[0], tarea = _ref1[1], newbox = _ref1[2], (_ref2 = _ref1[3], dW = _ref2[0], dH = _ref2[1]);
      if ((sarea - tarea < 256 || (sarea * 0.5 <= tarea && dW < 20 && dH < 20)) && !skipNext) {
        newboxes.push(newbox);
        skipNext = true;
      } else {
        if (!skipNext) {
          newboxes.push(boxes[i]);
        }
        skipNext = false;
      }
    }
    if (!skipNext) {
      newboxes.push(boxes[boxes.length - 1]);
    }
  }
  return newboxes;
};
