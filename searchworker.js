// Generated by CoffeeScript 1.3.3
var imageSearch, rowCache;

addEventListener('message', function(e) {
  var block, blocks, candidate, candidates, coords, data, frame, h, isSubset, offsetX, offsetY, p, reduced, row, subset, subsets, test, w, xoff, xsub, yoff, ysub, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1;
  blocks = e.data;
  return postMessage(blocks);
  p = 0;
  for (_i = 0, _len = blocks.length; _i < _len; _i++) {
    block = blocks[_i];
    postMessage((++p / blocks.length) / 2);
    data = new Uint8ClampedArray(block.pixels);
    block.pixels = {
      data: data,
      string: (function() {
        var _j, _ref, _results;
        _results = [];
        for (row = _j = 0, _ref = block.h; 0 <= _ref ? _j < _ref : _j > _ref; row = 0 <= _ref ? ++_j : --_j) {
          _results.push(rowCache(data, row, block.w));
        }
        return _results;
      })(),
      width: block.w,
      height: block.h
    };
  }
  p = 0;
  for (_j = 0, _len1 = blocks.length; _j < _len1; _j++) {
    block = blocks[_j];
    postMessage(0.5 + (++p / blocks.length) / 2);
    candidates = (function() {
      var _k, _len2, _results;
      _results = [];
      for (_k = 0, _len2 = blocks.length; _k < _len2; _k++) {
        test = blocks[_k];
        if (!test.isSubset && test.w >= block.w && test.h >= block.h && test !== block) {
          _results.push(test);
        }
      }
      return _results;
    })();
    for (_k = 0, _len2 = candidates.length; _k < _len2; _k++) {
      candidate = candidates[_k];
      coords = imageSearch(block.pixels, candidate.pixels);
      if (coords) {
        block.isSubset = true;
        delete block.pixels;
        block.coords = coords;
        if (!('subsets' in candidate)) {
          candidate.subsets = [];
        }
        candidate.subsets.push(block);
        if ('subsets' in block) {
          xoff = coords[0], yoff = coords[1];
          _ref = block.subsets;
          for (_l = 0, _len3 = _ref.length; _l < _len3; _l++) {
            subset = _ref[_l];
            _ref1 = subset.coords, xsub = _ref1[0], ysub = _ref1[1];
            subset.coords = [xoff + xsub, yoff + ysub];
            candidate.subsets.push(subset);
          }
        }
        break;
      }
    }
  }
  postMessage("o captain my captain");
  reduced = (function() {
    var _len4, _m, _ref2, _results;
    _results = [];
    for (_m = 0, _len4 = blocks.length; _m < _len4; _m++) {
      _ref2 = blocks[_m], isSubset = _ref2.isSubset, frame = _ref2.frame, w = _ref2.w, h = _ref2.h, offsetX = _ref2.offsetX, offsetY = _ref2.offsetY, subsets = _ref2.subsets;
      if (!isSubset) {
        _results.push({
          w: w,
          h: h,
          frame: frame,
          offsetX: offsetX,
          offsetY: offsetY,
          subsets: subsets
        });
      }
    }
    return _results;
  })();
  return postMessage(reduced);
});

rowCache = function(pixels, y, width) {
  var pix, row, x, _i;
  row = "";
  for (x = _i = 0; 0 <= width ? _i < width : _i > width; x = 0 <= width ? ++_i : --_i) {
    pix = (y * width + x) * 4;
    row += String.fromCharCode(pixels[pix]);
  }
  return row;
};

imageSearch = function(needle, haystack) {
  var bestReduce, bestRow, confirmTheory, firstRow, hpix, index, n, npix, nthCandidates, nthRow, pixc, reduce, row, rowCandidates, y, _i, _j, _k, _l, _len, _len1, _ref, _ref1;
  if (needle.width > haystack.width) {
    return null;
  }
  if (needle.height > haystack.height) {
    return null;
  }
  hpix = function(x, y) {
    var pix;
    pix = (y * haystack.width + x) * 4;
    return [haystack.data[pix], haystack.data[pix + 1], haystack.data[pix + 2]];
  };
  npix = function(x, y) {
    var pix;
    pix = (y * needle.width + x) * 4;
    return [needle.data[pix], needle.data[pix + 1], needle.data[pix + 2]];
  };
  pixc = function(_arg, _arg1) {
    var B, G, R, b, g, r;
    r = _arg[0], g = _arg[1], b = _arg[2];
    R = _arg1[0], G = _arg1[1], B = _arg1[2];
    return r === R && g === G && b === B;
  };
  confirmTheory = function(hx, hy) {
    var x, y, _i, _j, _ref, _ref1;
    for (y = _i = 1, _ref = needle.height; 1 <= _ref ? _i < _ref : _i > _ref; y = 1 <= _ref ? ++_i : --_i) {
      for (x = _j = 0, _ref1 = needle.width; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
        if (!pixc(hpix(hx + x, hy + y), npix(x, y))) {
          return;
        }
      }
    }
    return true;
  };
  firstRow = needle.string[0];
  rowCandidates = [];
  for (y = _i = 0, _ref = haystack.height - needle.height; 0 <= _ref ? _i < _ref : _i > _ref; y = 0 <= _ref ? ++_i : --_i) {
    row = haystack.string[y];
    if (row.indexOf(firstRow !== -1)) {
      rowCandidates.push(y);
    }
  }
  if (rowCandidates.length === 0) {
    return null;
  }
  bestReduce = 0;
  bestRow = 0;
  for (n = _j = 1, _ref1 = haystack.height; 1 <= _ref1 ? _j < _ref1 : _j > _ref1; n = 1 <= _ref1 ? ++_j : --_j) {
    nthRow = needle.string[n];
    nthCandidates = [];
    for (_k = 0, _len = rowCandidates.length; _k < _len; _k++) {
      y = rowCandidates[_k];
      row = haystack.string[y + n];
      if (row.indexOf(nthRow) !== -1) {
        nthCandidates.push(y);
      }
    }
    if (nthCandidates.length === 0) {
      return null;
    }
    reduce = rowCandidates.length - nthCandidates.length;
    if (reduce > bestReduce) {
      bestReduce = reduce;
      bestRow = n;
    }
    rowCandidates = nthCandidates;
    if (nthCandidates.length === 1) {
      break;
    }
  }
  if (rowCandidates.length > 100) {
    console.log("reduce failure", rowCandidates.length);
    return;
  }
  for (_l = 0, _len1 = rowCandidates.length; _l < _len1; _l++) {
    y = rowCandidates[_l];
    index = -1;
    nthRow = needle.string[bestRow];
    row = haystack.string[y + bestRow];
    while ((index = row.indexOf(nthRow, index + 1)) !== -1) {
      if (confirmTheory(index, y)) {
        return [index, y];
      }
    }
  }
};
